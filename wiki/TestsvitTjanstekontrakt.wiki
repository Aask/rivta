#summary Dokumentation för hur man skapar en testsvit för ett tjänstekontrakt

= Översikt =
Som verktyg för att skapa och exekvera testsviterna används SoapUI som finns på http://www.soapui.org/.

För att hålla testsviterna på en rimlig storlek är rekommendationen att göra ett SoapUI-projekt per tjänstekontrakt. 
Detta gör det möjligt för tjänsteleverantören att verifiera själva meddelandet i kontraktet.
Om domänen innehåller flera tjänstekontrakt som samverkar i en process, är ansatsen att göra ett separat SoapUI-projekt som verifiera flödet i processen genom flera kontrakt.

För varje tjänstekontrakt måste man skapa två SoapUI-projekt, där det första är själva testsviten och det andra innehåller en mock-tjänst som används vid utveckling och underhåll av sviten.

För att på enklast sätt få mock-tjänsten att returnera rätt svar på en Request används en HttpHeader (“x-mock-response”) som innehåller namnet på det svar som ska användas, varje Request i testsviten måste därför innehålla denna HttpHeader.

==Referensimplementation==
För att visa hur en testsvit kan se ut finns det en referensimplementation under https://code.google.com/p/rivta/source/browse/#svn%2Ftools%2Ftest%2Freference-suite. Denna testsvit innehåller samtliga delar som beskrivs nedan och kan med fördel användas som mall för en ny testsvit.

==Schematron-validering==
För vissa affärsregler räcker det inte att använda XML Schema, och då är rekommendationen att skapa Schematron-regler som kan validera meddelanden ytterligare. För att hitta de konstruktioner där Schematron behövs får man jämföra Schema-definitionen av kontraktet med dess fältregler och se om det finns avvikande definitioner.
De områden där Schematron kan hjälpa till handlar oftast om regler som anger att "om fält A har ett värde får inte fält B anges".
Mer information om Schematron finns på http://www.schematron.com/.

Se script-avsnittet nedan för meddelanden valideras mot Schematron-regler.

==Skapa testprojekt==
 # Create a SoapUI project for the contract where the test suite will be created, should be named as the contract
 # Import the WSDL-file for the contract
 # Add a TestSuite in the project.

==Creating the mock project==
 # Create another SoapUI project where the mock services will be created, should be named as the contract with suffix “Mock”
 # Import the WSDL-file for the contract and mark the “Create MockService” checkbox.
 # Open the “Mock Operation” dialog and choose “Script” as dispatch. To make the response dispatch selection, paste the following lines last in the script editor:
{{{
def responseName = mockRequest.requestHeaders['x-mock-response'][0]
log.debug("responseName: ${responseName}")

return responseName
}}}
 # The script can also contain other logic that is used to read values from the request, but this should be the least amount of code used to select the correct response.
 # Now you should be ready to create test cases.

==Create testcase==
 # Add a TestCase under the TestSuite
 # Add a Script step “Read data” under the new TestCase, that is used to read the test data.
 # Add a Test Request under the TestCase
 # Add the header “x-mock-response” to select which response should be sent back
 # Add the header “x-rivta-original-serviceconsumer-hsaid” with the value “${httpHeaderHsaId}”
 # Modify the contents of the request, so that it matches the current testcase. Variables are referecend with ${careUnitHsaId}
 # Add the following assertions (if applicable): Not Soap Fault, Respons SLA (15 seconds, Schema Compliance, SOAP Response
 # If there are Schematron validations available for the contract, add a Script Assertion that verifies the response. See Schematron script.
 # Add further assertions using Script, XPath or XQuery

==Script==
Här visas exempel på script som kan användas för att skapa en testsvit.

===Läsa testdata===
{{{
import se.skl.rivta.testsupport.soapui.datasource.XmlDataReader
import com.eviware.soapui.support.GroovyUtils

def utils = new GroovyUtils(context)
def dataFile = new File(utils.projectPath + "/data.xml")
def source = new XmlDataReader(context, dataFile)

source.load("Date_Boundaries")
}}}

===Schematron-validering===
{{{
import se.skl.rivta.testsupport.soapui.validation.SchematronValidator
import se.skl.rivta.testsupport.soapui.ContextHelper
import com.eviware.soapui.support.GroovyUtils

def utils = new GroovyUtils(context)
def contextHelper = new ContextHelper(context)
def validator = new SchematronValidator()

def failures = validator.validateMessage(messageExchange.response.getResponseContent(),
	new File(utils.projectPath + "/constraints.xml"))

failures.each { failure -> contextHelper.fail(failure.text) }
}}}