#summary Dokumentation för hur man skapar en testsvit för ett tjänstekontrakt

= Introduction =

To keep the testsuites at a reasonable size it is recomended to create one SoapUI project per Service Contract. This would make it easy to verify separate messages within the contract.
If the service domain is a process domain, where several contracts are used together, it is recomended to create a separate SoapUI project that verifies the implementation of the process.

For each contract there will be two different SoapUI projects, one for the test suite and one that will contain a mock service that is used to create and maintain the test suite.

To simplify the mocking of responses, a Http-Header (“x-mock-response”) is used to select which response that should be used. Every request in the test suite must therefore contain this extra header.

==Create Schematron validation rules==
There are some rules that cannot easily be described using the Schema language, and to verify the response messages there is a possibility to use the Schematron language to further verify details of a message. To create Schematron rules, you have to compare the Schema rules and the business-rules described in “Fältregler” for each contract. 

==Creating the test project==
 # Create a SoapUI project for the contract where the test suite will be created, should be named as the contract
 # Import the WSDL-file for the contract
 # Add a TestSuite in the project.

==Creating the mock project==
 # Create another SoapUI project where the mock services will be created, should be named as the contract with suffix “Mock”
 # Import the WSDL-file for the contract and mark the “Create MockService” checkbox.
 # Open the “Mock Operation” dialog and choose “Script” as dispatch. To make the response dispatch selection, paste the following lines last in the script editor:
{{{
def responseName = mockRequest.requestHeaders['x-mock-response'][0]
log.debug("responseName: ${responseName}")

return responseName
}}}
 # The script can also contain other logic that is used to read values from the request, but this should be the least amount of code used to select the correct response.
 # Now you should be ready to create test cases.

==Create testcase==
 # Add a TestCase under the TestSuite
 # Add a Script step “Read data” under the new TestCase, that is used to read the test data.
 # Add a Test Request under the TestCase
 # Add the header “x-mock-response” to select which response should be sent back
 # Add the header “x-rivta-original-serviceconsumer-hsaid” with the value “${httpHeaderHsaId}”
 # Modify the contents of the request, so that it matches the current testcase. Variables are referecend with ${careUnitHsaId}
 # Add the following assertions (if applicable): Not Soap Fault, Respons SLA (15 seconds, Schema Compliance, SOAP Response
 # If there are Schematron validations available for the contract, add a Script Assertion that verifies the response. See Schematron script.
 # Add further assertions using Script, XPath or XQuery


===Read data script===
{{{
import se.skl.rivta.testsupport.soapui.datasource.XmlDataReader
import com.eviware.soapui.support.GroovyUtils

def utils = new GroovyUtils(context)
def dataFile = new File(utils.projectPath + "/data.xml")
def source = new XmlDataReader(context, dataFile)

source.load("Date_Boundaries")
}}}

===Schematron validation script===
{{{
import se.skl.rivta.testsupport.soapui.validation.SchematronValidator
import se.skl.rivta.testsupport.soapui.ContextHelper
import com.eviware.soapui.support.GroovyUtils

def utils = new GroovyUtils(context)
def contextHelper = new ContextHelper(context)
def validator = new SchematronValidator()

def failures = validator.validateMessage(messageExchange.response.getResponseContent(),
	new File(utils.projectPath + "/constraints.xml"))

failures.each { failure -> contextHelper.fail(failure.text) }
}}}