#summary Dokumentation för hur man skapar en testsvit för ett tjänstekontrakt

= Översikt =
Som verktyg för att skapa och exekvera testsviterna används SoapUI som finns på http://www.soapui.org/.

För att hålla testsviterna på en rimlig storlek är rekommendationen att göra ett SoapUI-projekt per tjänstekontrakt. 
Detta gör det möjligt för tjänsteleverantören att verifiera själva meddelandet i kontraktet.
Om domänen innehåller flera tjänstekontrakt som samverkar i en process, är ansatsen att göra ett separat SoapUI-projekt som verifiera flödet i processen genom flera kontrakt.

För varje tjänstekontrakt måste man skapa två SoapUI-projekt, där det första är själva testsviten och det andra innehåller en mock-tjänst som används vid utveckling och underhåll av sviten.

För att på enklast sätt få mock-tjänsten att returnera rätt svar på en Request används en HttpHeader (“x-mock-response”) som innehåller namnet på det svar som ska användas, varje Request i testsviten måste därför innehålla denna HttpHeader.

==Referensimplementation==
För att visa hur en testsvit kan se ut finns det en referensimplementation under https://code.google.com/p/rivta/source/browse/#svn%2Ftools%2Ftest%2Freference-suite. Denna testsvit innehåller samtliga delar som beskrivs nedan och kan med fördel användas som mall för en ny testsvit.

==Schematron-validering==
För vissa affärsregler räcker det inte att använda XML Schema, och då är rekommendationen att skapa Schematron-regler som kan validera meddelanden ytterligare. För att hitta de konstruktioner där Schematron behövs får man jämföra Schema-definitionen av kontraktet med dess fältregler och se om det finns avvikande definitioner.
De områden där Schematron kan hjälpa till handlar oftast om regler som anger att "om fält A har ett värde får inte fält B anges".
Mer information om Schematron finns på http://www.schematron.com/.

Se script-avsnittet nedan för meddelanden valideras mot Schematron-regler.

==Skapa testprojekt==
 # Skapa ett SoapUI-projekt för tjänstekontraktet, detta ska namnges med samma namn som kontraktet.
 # Importera WSDL-filen för kontraktet.
 # Lägg till en TestSuite i projektet.

==Skapa mockprojekt==
 # Skapa ytterligare ett SoapUI-projekt, som ska innehålla mock-tjänsterna. Detta ska namnges med samma namn som kontraktet med tillägget "Mock" sist.
 # Importera WSDL-filen för kontraktet och välj "Create MockService" i guiden.
 # Öppna "Mock Operation"-dialogen och välj "Script" som Dispatch. För att välja vilket svar mock-tjänsten ska returnera baserat på ovan nämnda HttpHeader, klistra in följande rader sist i script-editorn:
{{{
def responseName = mockRequest.requestHeaders['x-mock-response'][0]
log.debug("responseName: ${responseName}")

return responseName
}}}
 # Scriptet kan även innehålla annan logik för att hämta värden från Request'en, men detta bör vara den minsta mängden kod som används för att välja rätt Response för givet Request.
 # Du bör nu vara redo att skapa själva testfallen.

==Skapa testfall==
 # Lägg till ett TestCase under TestSuite'n.
 # Lägg till ett "Script step" som namnges “Read data” under det nya TestCase't, som används för att läsa in testdata. Se exempel på script nedan.
 # Lägg till ett "Test Request" efter Script-steget.
 # Lägg till en HttpHeader “x-mock-response” för att låta mock-tjänsten kunna välja lämpligt svar på Request'en.
 # Lägg till en HttpHeader “x-rivta-original-serviceconsumer-hsaid” med värdet “${httpHeaderHsaId}”. Värdet på variabel läses in av script-steget.
 # Anpassa innehållet i Request'en så att det återspeglar det som ska verifieras av ditt testfall. Variabler refereras med ${careUnitHsaId}.
 # Lägg till lämpliga verifieringar av svaret: Not Soap Fault, Respons SLA (15 sekunder), Schema Compliance, SOAP Response.
 # Om det finns Schematron-regler för kontraktet, lägg till en "Script Assertion" som kontrollerar meddelandet mot dessa reglerna. Se script nedan.
 # Lägg till ytterligare valideringar med Script, Xpath eller XQuery.

==Script==
Här visas exempel på script som kan användas för att skapa en testsvit.

===Läsa testdata===
{{{
import se.skl.rivta.testsupport.soapui.datasource.XmlDataReader
import com.eviware.soapui.support.GroovyUtils

def utils = new GroovyUtils(context)
def dataFile = new File(utils.projectPath + "/data.xml")
def source = new XmlDataReader(context, dataFile)

source.load("Date_Boundaries")
}}}

===Schematron-validering===
{{{
import se.skl.rivta.testsupport.soapui.validation.SchematronValidator
import se.skl.rivta.testsupport.soapui.ContextHelper
import com.eviware.soapui.support.GroovyUtils

def utils = new GroovyUtils(context)
def contextHelper = new ContextHelper(context)
def validator = new SchematronValidator()

def failures = validator.validateMessage(messageExchange.response.getResponseContent(),
	new File(utils.projectPath + "/constraints.xml"))

failures.each { failure -> contextHelper.fail(failure.text) }
}}}
===Validering av meddelandets innehåll===
Detta script validerar att svaret endast innehåller samma PatientId och PatientIdType som skickades i Requesten.
{{{
import com.eviware.soapui.support.XmlHolder
import se.skl.rivta.testsupport.soapui.ContextHelper
import com.eviware.soapui.support.GroovyUtils

def utils = new GroovyUtils(context)
def contextHelper = new ContextHelper(context)

def holder = new XmlHolder( messageExchange.response.responseContent )
holder.namespaces['soapenv'] = 'http://schemas.xmlsoap.org/soap/envelope/'
holder.namespaces['urn'] = 'urn:riv:clinicalprocess:logistics:logistics:GetCareContactsResponder:2'
holder.namespaces['urn1'] = 'urn:riv:clinicalprocess:logistics:logistics:2'

def careContacts = holder.getDomNodes('/soapenv:Envelope/soapenv:Body/urn:GetCareContactsResponse/urn:careContact')

careContacts.each {c -> 
	def contactHolder = new XmlHolder( c )
	holder.namespaces.each {key, value -> contactHolder.namespaces[key] = value}

	def careContactId = contactHolder.getNodeValue('/urn:careContact/urn1:careContactHeader/urn1:careContactId')
	def patientId = contactHolder.getNodeValue('/urn:careContact/urn1:careContactHeader/urn1:patientId/urn1:id')
	def patientIdType = contactHolder.getNodeValue('/urn:careContact/urn1:careContactHeader/urn1:patientId/urn1:type')
	
	if (patientId != context.patientId) {
		contextHelper.fail("Response contains a contact with other PatientId. PatientId: ${patientId} CareContactId: ${careContactId}")
	}
	if (patientIdType != context.patientIdType ) {
		contextHelper.fail("Response contains a contact with other PatientIdType. PatientIdType: ${patientIdType} CareContactId: ${careContactId}")
	}
}
}}}
===Mock-script===
Detta script är ett exempel för hur mock-tjänsten hämtar värden från Request'en, som sedan blir tillgängliga att använda i svaret som returneras.
{{{
import com.eviware.soapui.support.XmlHolder

def holder = new XmlHolder( mockRequest.requestContent )
holder.namespaces['soapenv'] = 'http://schemas.xmlsoap.org/soap/envelope/'
holder.namespaces['urn'] = 'urn:riv:itintegration:registry:1'
holder.namespaces['urn1'] = 'urn:riv:clinicalprocess:logistics:logistics:GetCareContactsResponder:2'
holder.namespaces['urn2'] = 'urn:riv:clinicalprocess:logistics:logistics:2'

def logicalAddress = holder.getNodeValue('/soapenv:Envelope/soapenv:Header/urn:LogicalAddress')
def careUnitHSAid = holder.getNodeValue('/soapenv:Envelope/soapenv:Body/urn1:GetCareContacts/urn1:careUnitHSAid')
def careContactId = holder.getNodeValue('/soapenv:Envelope/soapenv:Body/urn1:GetCareContacts/urn1:careContactId')
def sourceSystemHSAid = holder.getNodeValue('/soapenv:Envelope/soapenv:Body/urn1:GetCareContacts/urn1:sourceSystemHSAid')
def datePeriodStart = holder.getNodeValue('/soapenv:Envelope/soapenv:Body/urn1:GetCareContacts/urn1:timePeriod/urn2:start')
def datePeriodEnd = holder.getNodeValue('/soapenv:Envelope/soapenv:Body/urn1:GetCareContacts/urn1:timePeriod/urn2:end')
def patientId = holder.getNodeValue('/soapenv:Envelope/soapenv:Body/urn1:GetCareContacts/urn1:patientId/urn2:id')
def patientIdType = holder.getNodeValue('/soapenv:Envelope/soapenv:Body/urn1:GetCareContacts/urn1:patientId/urn2:type')

context.patientId = patientId
context.patientIdType = patientIdType
context.careUnitHSAid = careUnitHSAid

def responseName = mockRequest.requestHeaders['x-mock-response'][0]
log.debug("responseName: ${responseName}")

return responseName
}}}